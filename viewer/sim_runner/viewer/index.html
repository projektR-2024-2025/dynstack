<!DOCTYPE html>
<html>
<head>
    <title>DynStack Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: white;
        }
        #canvas {
            border: 1px solid #ccc;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            background-color: #f0f0f0;
        }
        #messages {
            height: 200px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1 id="naslov">DynStack Viewer</h1>
    <div id="status">WebSocket: Disconnected</div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="msg"></div>
    <div id="ocjena"></div>

    <script>
        const naslov = document.getElementById('naslov');
        const status = document.getElementById('status');
        const ocjena = document.getElementById('ocjena');
        const msg = document.getElementById('msg');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const ws = new WebSocket('ws://localhost:8765');

        ws.onopen = () => {
            status.textContent = 'WebSocket: Connected';
            status.style.backgroundColor = '#4CAF50';
        };

        ws.onclose = () => {
            status.textContent = 'WebSocket: Disconnected';
            status.style.backgroundColor = '#ff4d4d';
        };

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.KPIs) {
                    ocjena.textContent = `${JSON.stringify(data.KPIs, null, 4)}`;
                    blockedArrival = data.KPIs.BlockedArrivalTime ? data.KPIs.BlockedArrivalTime : 0;
                    msg.textContent = `SCORE: ${0.5 * blockedArrival - 0.4 * data.KPIs.TotalBlocksOnTime + 0.1 * data.KPIs.CraneManipulations}`;
                }
                updateVisualization(data);
            } catch (error) {
                console.log('Error', `Failed to parse message: ${error}`);
            }
        };

        function millisToMinutesAndSeconds(millis) {
            negative = millis < 0;
            millis = Math.abs(millis);
            var minutes = Math.floor(millis / 60000);
            var seconds = ((millis % 60000) / 1000).toFixed(0);
            return (negative ? '-' : '') + minutes + ":" + (seconds < 10 ? '0' : '') + seconds;
        }

        const colors = {
            gray: '#999',
            lightGray: '#ddd',
            red: '#ff4d4d',
            green: '#4CAF50',
            orange: '#ff9800',
            black: '#000',
            white: '#fff',
        };

        const bounds = {
            margin: 50,
            bufferX: 200,
            handoverX: 650,
            blockWidth: 100,
            blockHeight: 30,
            blockMargin: 35,
        }

        function drawBlock(x, y, width, height, label, time, isOverdue = false, isReady = false) {
            ctx.fillStyle = isOverdue ? colors.red : isReady ? colors.green : colors.gray;
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = colors.black;
            ctx.strokeRect(x, y, width, height);

            ctx.fillStyle = colors.white;
            ctx.font = '12px Arial';
            ctx.fillText(label, x + 10, y + 20);
            ctx.fillText(time, x + 60, y + 20);
        }

        function drawCrane(crane, time = 0) {
            x = bounds.margin;
            y = (canvas.height - bounds.margin) - Math.round(crane.HoistPosition * (canvas.height - (2 * bounds.margin) - bounds.blockHeight));
            w = bounds.blockHeight;
            h = bounds.blockHeight;
            if(crane.GirderPosition) {
                x = Math.round((canvas.width - (2 * bounds.margin) - bounds.blockHeight) * crane.GirderPosition)
            }
            if(crane.Load) {
                time = crane.Load.Due.MilliSeconds - time
                drawBlock(x, y, bounds.blockWidth, bounds.blockHeight, `${crane.Load.Id}`,
                millisToMinutesAndSeconds(time), time < 0, crane.Load.Ready);
            }
            ctx.fillStyle = colors.green;
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = colors.black;
            ctx.strokeRect(x, y, w, h);
        }

        function updateVisualization(data) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const margin = bounds.margin;
            var bufferX = bounds.bufferX;
            const handoverX = bounds.handoverX;
            const blockWidth = bounds.blockWidth;
            const blockHeight = bounds.blockHeight;
            const blockMargin = bounds.blockMargin;
            const stackY = canvas.height - (2*margin)

            ctx.fillStyle = colors.white;
            ctx.font = '12px Arial';
            
            if (data.Production.BottomToTop) {
                ctx.fillText(`Arrival (${data.Production.MaxHeight - data.Production.BottomToTop.length})`, margin, canvas.height - margin);
                arr_y = stackY
                data.Production.BottomToTop.forEach(block => {
                    time = block.Due.MilliSeconds - data.Now.MilliSeconds
                    drawBlock(margin, arr_y, blockWidth, blockHeight, `${block.Id}`,
                    millisToMinutesAndSeconds(time), time < 0, block.Ready);
                    arr_y -= blockMargin
                });
            }

            data.Buffers.forEach(buff => {
                if (buff.BottomToTop) {
                    ctx.fillText(`Buffer ${buff.Id} (${buff.MaxHeight - buff.BottomToTop.length})`, bufferX, canvas.height - margin);
                    y = stackY
                    buff.BottomToTop.forEach(block => {
                        time = block.Due.MilliSeconds - data.Now.MilliSeconds
                        drawBlock(bufferX, y, blockWidth, blockHeight, `${block.Id}`,
                        millisToMinutesAndSeconds(time), time < 0, block.Ready);
                        y -= blockMargin
                    });
                    bufferX += 150;
                }
            });

            drawCrane(data.Crane, data.Now.MilliSeconds)

            ctx.fillStyle = data.Handover.Ready ? colors.green : colors.red;
            ctx.fillText('Handover stack', handoverX, canvas.height - margin);
        }
    </script>
</body>
</html>