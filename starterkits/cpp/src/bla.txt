class move
apply_move
getallpossiblemoves
extract_features

class heuristic
    init(ECF tree priority_function):
        priority_function = priority_function
    calculate_move(sim):
        moves = getallpossiblemoves(world)

        for move in moves():
            sim_c = sim.copy()
            apply_move(sim_c, move)
            input = extract_features(sim_c.getworld)
            priority= priority_function(input)

            sim_c.destructor

        move = move with best priority
        return move

run_simulation(sim&, heuristic, max_steps):
    for (int step = 0; step < max_steps; step++) {

        Move m = heuristic(sim);

        switch (m.type) {
        case MoveType::ARRIVAL_TO_BUFFER:
            sim.move_arrival_to_buffer(m.to);
            break;

        case MoveType::BUFFER_TO_BUFFER:
            sim.move_buffer_to_buffer(m.from, m.to);
            break;

        case MoveType::BUFFER_TO_HANDOVER:
            sim.move_buffer_to_handover(m.from);
            break;

        case MoveType::NONE:
            break;
        }

        sim.step();
    }

def fitness(world):
    return world.kpi.sum()

