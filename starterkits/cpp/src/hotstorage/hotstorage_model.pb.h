// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: hotstorage_model.proto
// Protobuf C++ Version: 5.29.5

#ifndef hotstorage_5fmodel_2eproto_2epb_2eh
#define hotstorage_5fmodel_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_hotstorage_5fmodel_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_hotstorage_5fmodel_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_hotstorage_5fmodel_2eproto;
namespace DynStacking {
namespace HotStorage {
namespace DataModel {
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Crane;
struct CraneDefaultTypeInternal;
extern CraneDefaultTypeInternal _Crane_default_instance_;
class CraneMove;
struct CraneMoveDefaultTypeInternal;
extern CraneMoveDefaultTypeInternal _CraneMove_default_instance_;
class CraneSchedule;
struct CraneScheduleDefaultTypeInternal;
extern CraneScheduleDefaultTypeInternal _CraneSchedule_default_instance_;
class Handover;
struct HandoverDefaultTypeInternal;
extern HandoverDefaultTypeInternal _Handover_default_instance_;
class Performance;
struct PerformanceDefaultTypeInternal;
extern PerformanceDefaultTypeInternal _Performance_default_instance_;
class Stack;
struct StackDefaultTypeInternal;
extern StackDefaultTypeInternal _Stack_default_instance_;
class TimeStamp;
struct TimeStampDefaultTypeInternal;
extern TimeStampDefaultTypeInternal _TimeStamp_default_instance_;
class Uncertainties;
struct UncertaintiesDefaultTypeInternal;
extern UncertaintiesDefaultTypeInternal _Uncertainties_default_instance_;
class World;
struct WorldDefaultTypeInternal;
extern WorldDefaultTypeInternal _World_default_instance_;
}  // namespace DataModel
}  // namespace HotStorage
}  // namespace DynStacking
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace DynStacking {
namespace HotStorage {
namespace DataModel {

// ===================================================================


// -------------------------------------------------------------------

class Uncertainties final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.Uncertainties) */ {
 public:
  inline Uncertainties() : Uncertainties(nullptr) {}
  ~Uncertainties() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Uncertainties* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Uncertainties));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Uncertainties(
      ::google::protobuf::internal::ConstantInitialized);

  inline Uncertainties(const Uncertainties& from) : Uncertainties(nullptr, from) {}
  inline Uncertainties(Uncertainties&& from) noexcept
      : Uncertainties(nullptr, std::move(from)) {}
  inline Uncertainties& operator=(const Uncertainties& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uncertainties& operator=(Uncertainties&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uncertainties& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uncertainties* internal_default_instance() {
    return reinterpret_cast<const Uncertainties*>(
        &_Uncertainties_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Uncertainties& a, Uncertainties& b) { a.Swap(&b); }
  inline void Swap(Uncertainties* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uncertainties* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uncertainties* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Uncertainties>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Uncertainties& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Uncertainties& from) { Uncertainties::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Uncertainties* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.Uncertainties"; }

 protected:
  explicit Uncertainties(::google::protobuf::Arena* arena);
  Uncertainties(::google::protobuf::Arena* arena, const Uncertainties& from);
  Uncertainties(::google::protobuf::Arena* arena, Uncertainties&& from) noexcept
      : Uncertainties(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArrivalIntervalsFieldNumber = 1,
    kCraneMoveTimesFieldNumber = 2,
    kHandoverReadyIntervalsFieldNumber = 3,
  };
  // repeated double ArrivalIntervals = 1 [packed = false];
  int arrivalintervals_size() const;
  private:
  int _internal_arrivalintervals_size() const;

  public:
  void clear_arrivalintervals() ;
  double arrivalintervals(int index) const;
  void set_arrivalintervals(int index, double value);
  void add_arrivalintervals(double value);
  const ::google::protobuf::RepeatedField<double>& arrivalintervals() const;
  ::google::protobuf::RepeatedField<double>* mutable_arrivalintervals();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_arrivalintervals() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_arrivalintervals();

  public:
  // repeated double CraneMoveTimes = 2 [packed = false];
  int cranemovetimes_size() const;
  private:
  int _internal_cranemovetimes_size() const;

  public:
  void clear_cranemovetimes() ;
  double cranemovetimes(int index) const;
  void set_cranemovetimes(int index, double value);
  void add_cranemovetimes(double value);
  const ::google::protobuf::RepeatedField<double>& cranemovetimes() const;
  ::google::protobuf::RepeatedField<double>* mutable_cranemovetimes();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_cranemovetimes() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_cranemovetimes();

  public:
  // repeated double HandoverReadyIntervals = 3 [packed = false];
  int handoverreadyintervals_size() const;
  private:
  int _internal_handoverreadyintervals_size() const;

  public:
  void clear_handoverreadyintervals() ;
  double handoverreadyintervals(int index) const;
  void set_handoverreadyintervals(int index, double value);
  void add_handoverreadyintervals(double value);
  const ::google::protobuf::RepeatedField<double>& handoverreadyintervals() const;
  ::google::protobuf::RepeatedField<double>* mutable_handoverreadyintervals();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_handoverreadyintervals() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_handoverreadyintervals();

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.Uncertainties)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Uncertainties& from_msg);
    ::google::protobuf::RepeatedField<double> arrivalintervals_;
    ::google::protobuf::RepeatedField<double> cranemovetimes_;
    ::google::protobuf::RepeatedField<double> handoverreadyintervals_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class TimeStamp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.TimeStamp) */ {
 public:
  inline TimeStamp() : TimeStamp(nullptr) {}
  ~TimeStamp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TimeStamp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TimeStamp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimeStamp(
      ::google::protobuf::internal::ConstantInitialized);

  inline TimeStamp(const TimeStamp& from) : TimeStamp(nullptr, from) {}
  inline TimeStamp(TimeStamp&& from) noexcept
      : TimeStamp(nullptr, std::move(from)) {}
  inline TimeStamp& operator=(const TimeStamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeStamp& operator=(TimeStamp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeStamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeStamp* internal_default_instance() {
    return reinterpret_cast<const TimeStamp*>(
        &_TimeStamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(TimeStamp& a, TimeStamp& b) { a.Swap(&b); }
  inline void Swap(TimeStamp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeStamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeStamp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TimeStamp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeStamp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimeStamp& from) { TimeStamp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TimeStamp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.TimeStamp"; }

 protected:
  explicit TimeStamp(::google::protobuf::Arena* arena);
  TimeStamp(::google::protobuf::Arena* arena, const TimeStamp& from);
  TimeStamp(::google::protobuf::Arena* arena, TimeStamp&& from) noexcept
      : TimeStamp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMilliSecondsFieldNumber = 1,
  };
  // int64 MilliSeconds = 1;
  void clear_milliseconds() ;
  ::int64_t milliseconds() const;
  void set_milliseconds(::int64_t value);

  private:
  ::int64_t _internal_milliseconds() const;
  void _internal_set_milliseconds(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.TimeStamp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TimeStamp& from_msg);
    ::int64_t milliseconds_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Performance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.Performance) */ {
 public:
  inline Performance() : Performance(nullptr) {}
  ~Performance() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Performance* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Performance));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Performance(
      ::google::protobuf::internal::ConstantInitialized);

  inline Performance(const Performance& from) : Performance(nullptr, from) {}
  inline Performance(Performance&& from) noexcept
      : Performance(nullptr, std::move(from)) {}
  inline Performance& operator=(const Performance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Performance& operator=(Performance&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Performance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Performance* internal_default_instance() {
    return reinterpret_cast<const Performance*>(
        &_Performance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Performance& a, Performance& b) { a.Swap(&b); }
  inline void Swap(Performance* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Performance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Performance* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Performance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Performance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Performance& from) { Performance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Performance* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.Performance"; }

 protected:
  explicit Performance(::google::protobuf::Arena* arena);
  Performance(::google::protobuf::Arena* arena, const Performance& from);
  Performance(::google::protobuf::Arena* arena, Performance&& from) noexcept
      : Performance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kServiceLevelMeanFieldNumber = 2,
    kCraneManipulationsFieldNumber = 1,
    kDeliveredBlocksFieldNumber = 4,
    kLeadTimeMeanFieldNumber = 3,
    kBlockedArrivalTimeFieldNumber = 6,
    kTardinessMeanFieldNumber = 7,
    kBufferUtilizationMeanFieldNumber = 8,
    kCraneUtilizationMeanFieldNumber = 9,
    kHandoverUtilizationMeanFieldNumber = 10,
    kUpstreamUtilizationMeanFieldNumber = 11,
    kTotalBlocksOnTimeFieldNumber = 5,
  };
  // double ServiceLevelMean = 2;
  void clear_servicelevelmean() ;
  double servicelevelmean() const;
  void set_servicelevelmean(double value);

  private:
  double _internal_servicelevelmean() const;
  void _internal_set_servicelevelmean(double value);

  public:
  // int32 CraneManipulations = 1;
  void clear_cranemanipulations() ;
  ::int32_t cranemanipulations() const;
  void set_cranemanipulations(::int32_t value);

  private:
  ::int32_t _internal_cranemanipulations() const;
  void _internal_set_cranemanipulations(::int32_t value);

  public:
  // int32 DeliveredBlocks = 4;
  void clear_deliveredblocks() ;
  ::int32_t deliveredblocks() const;
  void set_deliveredblocks(::int32_t value);

  private:
  ::int32_t _internal_deliveredblocks() const;
  void _internal_set_deliveredblocks(::int32_t value);

  public:
  // double LeadTimeMean = 3;
  void clear_leadtimemean() ;
  double leadtimemean() const;
  void set_leadtimemean(double value);

  private:
  double _internal_leadtimemean() const;
  void _internal_set_leadtimemean(double value);

  public:
  // double BlockedArrivalTime = 6;
  void clear_blockedarrivaltime() ;
  double blockedarrivaltime() const;
  void set_blockedarrivaltime(double value);

  private:
  double _internal_blockedarrivaltime() const;
  void _internal_set_blockedarrivaltime(double value);

  public:
  // double TardinessMean = 7;
  void clear_tardinessmean() ;
  double tardinessmean() const;
  void set_tardinessmean(double value);

  private:
  double _internal_tardinessmean() const;
  void _internal_set_tardinessmean(double value);

  public:
  // double BufferUtilizationMean = 8;
  void clear_bufferutilizationmean() ;
  double bufferutilizationmean() const;
  void set_bufferutilizationmean(double value);

  private:
  double _internal_bufferutilizationmean() const;
  void _internal_set_bufferutilizationmean(double value);

  public:
  // double CraneUtilizationMean = 9;
  void clear_craneutilizationmean() ;
  double craneutilizationmean() const;
  void set_craneutilizationmean(double value);

  private:
  double _internal_craneutilizationmean() const;
  void _internal_set_craneutilizationmean(double value);

  public:
  // double HandoverUtilizationMean = 10;
  void clear_handoverutilizationmean() ;
  double handoverutilizationmean() const;
  void set_handoverutilizationmean(double value);

  private:
  double _internal_handoverutilizationmean() const;
  void _internal_set_handoverutilizationmean(double value);

  public:
  // double UpstreamUtilizationMean = 11;
  void clear_upstreamutilizationmean() ;
  double upstreamutilizationmean() const;
  void set_upstreamutilizationmean(double value);

  private:
  double _internal_upstreamutilizationmean() const;
  void _internal_set_upstreamutilizationmean(double value);

  public:
  // int32 TotalBlocksOnTime = 5;
  void clear_totalblocksontime() ;
  ::int32_t totalblocksontime() const;
  void set_totalblocksontime(::int32_t value);

  private:
  ::int32_t _internal_totalblocksontime() const;
  void _internal_set_totalblocksontime(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.Performance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Performance& from_msg);
    double servicelevelmean_;
    ::int32_t cranemanipulations_;
    ::int32_t deliveredblocks_;
    double leadtimemean_;
    double blockedarrivaltime_;
    double tardinessmean_;
    double bufferutilizationmean_;
    double craneutilizationmean_;
    double handoverutilizationmean_;
    double upstreamutilizationmean_;
    ::int32_t totalblocksontime_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class CraneMove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.CraneMove) */ {
 public:
  inline CraneMove() : CraneMove(nullptr) {}
  ~CraneMove() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CraneMove* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CraneMove));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CraneMove(
      ::google::protobuf::internal::ConstantInitialized);

  inline CraneMove(const CraneMove& from) : CraneMove(nullptr, from) {}
  inline CraneMove(CraneMove&& from) noexcept
      : CraneMove(nullptr, std::move(from)) {}
  inline CraneMove& operator=(const CraneMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline CraneMove& operator=(CraneMove&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CraneMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const CraneMove* internal_default_instance() {
    return reinterpret_cast<const CraneMove*>(
        &_CraneMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CraneMove& a, CraneMove& b) { a.Swap(&b); }
  inline void Swap(CraneMove* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CraneMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CraneMove* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CraneMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CraneMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CraneMove& from) { CraneMove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CraneMove* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.CraneMove"; }

 protected:
  explicit CraneMove(::google::protobuf::Arena* arena);
  CraneMove(::google::protobuf::Arena* arena, const CraneMove& from);
  CraneMove(::google::protobuf::Arena* arena, CraneMove&& from) noexcept
      : CraneMove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
    kSequenceFieldNumber = 4,
    kEmptyMoveFieldNumber = 5,
  };
  // int32 BlockId = 1;
  void clear_blockid() ;
  ::int32_t blockid() const;
  void set_blockid(::int32_t value);

  private:
  ::int32_t _internal_blockid() const;
  void _internal_set_blockid(::int32_t value);

  public:
  // int32 SourceId = 2;
  void clear_sourceid() ;
  ::int32_t sourceid() const;
  void set_sourceid(::int32_t value);

  private:
  ::int32_t _internal_sourceid() const;
  void _internal_set_sourceid(::int32_t value);

  public:
  // int32 TargetId = 3;
  void clear_targetid() ;
  ::int32_t targetid() const;
  void set_targetid(::int32_t value);

  private:
  ::int32_t _internal_targetid() const;
  void _internal_set_targetid(::int32_t value);

  public:
  // int32 Sequence = 4;
  void clear_sequence() ;
  ::int32_t sequence() const;
  void set_sequence(::int32_t value);

  private:
  ::int32_t _internal_sequence() const;
  void _internal_set_sequence(::int32_t value);

  public:
  // bool EmptyMove = 5;
  void clear_emptymove() ;
  bool emptymove() const;
  void set_emptymove(bool value);

  private:
  bool _internal_emptymove() const;
  void _internal_set_emptymove(bool value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.CraneMove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CraneMove& from_msg);
    ::int32_t blockid_;
    ::int32_t sourceid_;
    ::int32_t targetid_;
    ::int32_t sequence_;
    bool emptymove_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class CraneSchedule final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.CraneSchedule) */ {
 public:
  inline CraneSchedule() : CraneSchedule(nullptr) {}
  ~CraneSchedule() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CraneSchedule* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CraneSchedule));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CraneSchedule(
      ::google::protobuf::internal::ConstantInitialized);

  inline CraneSchedule(const CraneSchedule& from) : CraneSchedule(nullptr, from) {}
  inline CraneSchedule(CraneSchedule&& from) noexcept
      : CraneSchedule(nullptr, std::move(from)) {}
  inline CraneSchedule& operator=(const CraneSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CraneSchedule& operator=(CraneSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CraneSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CraneSchedule* internal_default_instance() {
    return reinterpret_cast<const CraneSchedule*>(
        &_CraneSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CraneSchedule& a, CraneSchedule& b) { a.Swap(&b); }
  inline void Swap(CraneSchedule* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CraneSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CraneSchedule* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CraneSchedule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CraneSchedule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CraneSchedule& from) { CraneSchedule::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CraneSchedule* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.CraneSchedule"; }

 protected:
  explicit CraneSchedule(::google::protobuf::Arena* arena);
  CraneSchedule(::google::protobuf::Arena* arena, const CraneSchedule& from);
  CraneSchedule(::google::protobuf::Arena* arena, CraneSchedule&& from) noexcept
      : CraneSchedule(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMovesFieldNumber = 1,
    kSequenceNrFieldNumber = 2,
  };
  // repeated .DynStacking.HotStorage.DataModel.CraneMove Moves = 1;
  int moves_size() const;
  private:
  int _internal_moves_size() const;

  public:
  void clear_moves() ;
  ::DynStacking::HotStorage::DataModel::CraneMove* mutable_moves(int index);
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>* mutable_moves();

  private:
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>& _internal_moves() const;
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>* _internal_mutable_moves();
  public:
  const ::DynStacking::HotStorage::DataModel::CraneMove& moves(int index) const;
  ::DynStacking::HotStorage::DataModel::CraneMove* add_moves();
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>& moves() const;
  // int32 SequenceNr = 2;
  void clear_sequencenr() ;
  ::int32_t sequencenr() const;
  void set_sequencenr(::int32_t value);

  private:
  ::int32_t _internal_sequencenr() const;
  void _internal_set_sequencenr(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.CraneSchedule)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CraneSchedule& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DynStacking::HotStorage::DataModel::CraneMove > moves_;
    ::int32_t sequencenr_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Block final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Block* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Block));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Block(
      ::google::protobuf::internal::ConstantInitialized);

  inline Block(const Block& from) : Block(nullptr, from) {}
  inline Block(Block&& from) noexcept
      : Block(nullptr, std::move(from)) {}
  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
        &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Block& a, Block& b) { a.Swap(&b); }
  inline void Swap(Block* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Block>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Block& from) { Block::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Block* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.Block"; }

 protected:
  explicit Block(::google::protobuf::Arena* arena);
  Block(::google::protobuf::Arena* arena, const Block& from);
  Block(::google::protobuf::Arena* arena, Block&& from) noexcept
      : Block(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReleaseFieldNumber = 2,
    kDueFieldNumber = 3,
    kIdFieldNumber = 1,
    kReadyFieldNumber = 4,
  };
  // .DynStacking.HotStorage.DataModel.TimeStamp Release = 2;
  bool has_release() const;
  void clear_release() ;
  const ::DynStacking::HotStorage::DataModel::TimeStamp& release() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::TimeStamp* release_release();
  ::DynStacking::HotStorage::DataModel::TimeStamp* mutable_release();
  void set_allocated_release(::DynStacking::HotStorage::DataModel::TimeStamp* value);
  void unsafe_arena_set_allocated_release(::DynStacking::HotStorage::DataModel::TimeStamp* value);
  ::DynStacking::HotStorage::DataModel::TimeStamp* unsafe_arena_release_release();

  private:
  const ::DynStacking::HotStorage::DataModel::TimeStamp& _internal_release() const;
  ::DynStacking::HotStorage::DataModel::TimeStamp* _internal_mutable_release();

  public:
  // .DynStacking.HotStorage.DataModel.TimeStamp Due = 3;
  bool has_due() const;
  void clear_due() ;
  const ::DynStacking::HotStorage::DataModel::TimeStamp& due() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::TimeStamp* release_due();
  ::DynStacking::HotStorage::DataModel::TimeStamp* mutable_due();
  void set_allocated_due(::DynStacking::HotStorage::DataModel::TimeStamp* value);
  void unsafe_arena_set_allocated_due(::DynStacking::HotStorage::DataModel::TimeStamp* value);
  ::DynStacking::HotStorage::DataModel::TimeStamp* unsafe_arena_release_due();

  private:
  const ::DynStacking::HotStorage::DataModel::TimeStamp& _internal_due() const;
  ::DynStacking::HotStorage::DataModel::TimeStamp* _internal_mutable_due();

  public:
  // int32 Id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool Ready = 4;
  void clear_ready() ;
  bool ready() const;
  void set_ready(bool value);

  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.Block)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Block& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DynStacking::HotStorage::DataModel::TimeStamp* release_;
    ::DynStacking::HotStorage::DataModel::TimeStamp* due_;
    ::int32_t id_;
    bool ready_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Stack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.Stack) */ {
 public:
  inline Stack() : Stack(nullptr) {}
  ~Stack() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Stack* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Stack));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Stack(
      ::google::protobuf::internal::ConstantInitialized);

  inline Stack(const Stack& from) : Stack(nullptr, from) {}
  inline Stack(Stack&& from) noexcept
      : Stack(nullptr, std::move(from)) {}
  inline Stack& operator=(const Stack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stack& operator=(Stack&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stack* internal_default_instance() {
    return reinterpret_cast<const Stack*>(
        &_Stack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Stack& a, Stack& b) { a.Swap(&b); }
  inline void Swap(Stack* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stack* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Stack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Stack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Stack& from) { Stack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Stack* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.Stack"; }

 protected:
  explicit Stack(::google::protobuf::Arena* arena);
  Stack(::google::protobuf::Arena* arena, const Stack& from);
  Stack(::google::protobuf::Arena* arena, Stack&& from) noexcept
      : Stack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBottomToTopFieldNumber = 3,
    kIdFieldNumber = 1,
    kMaxHeightFieldNumber = 2,
  };
  // repeated .DynStacking.HotStorage.DataModel.Block BottomToTop = 3;
  int bottomtotop_size() const;
  private:
  int _internal_bottomtotop_size() const;

  public:
  void clear_bottomtotop() ;
  ::DynStacking::HotStorage::DataModel::Block* mutable_bottomtotop(int index);
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>* mutable_bottomtotop();

  private:
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>& _internal_bottomtotop() const;
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>* _internal_mutable_bottomtotop();
  public:
  const ::DynStacking::HotStorage::DataModel::Block& bottomtotop(int index) const;
  ::DynStacking::HotStorage::DataModel::Block* add_bottomtotop();
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>& bottomtotop() const;
  // int32 Id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 MaxHeight = 2;
  void clear_maxheight() ;
  ::int32_t maxheight() const;
  void set_maxheight(::int32_t value);

  private:
  ::int32_t _internal_maxheight() const;
  void _internal_set_maxheight(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.Stack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Stack& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DynStacking::HotStorage::DataModel::Block > bottomtotop_;
    ::int32_t id_;
    ::int32_t maxheight_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Handover final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.Handover) */ {
 public:
  inline Handover() : Handover(nullptr) {}
  ~Handover() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Handover* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Handover));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Handover(
      ::google::protobuf::internal::ConstantInitialized);

  inline Handover(const Handover& from) : Handover(nullptr, from) {}
  inline Handover(Handover&& from) noexcept
      : Handover(nullptr, std::move(from)) {}
  inline Handover& operator=(const Handover& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handover& operator=(Handover&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Handover& default_instance() {
    return *internal_default_instance();
  }
  static inline const Handover* internal_default_instance() {
    return reinterpret_cast<const Handover*>(
        &_Handover_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Handover& a, Handover& b) { a.Swap(&b); }
  inline void Swap(Handover* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handover* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Handover* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Handover>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Handover& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Handover& from) { Handover::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Handover* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.Handover"; }

 protected:
  explicit Handover(::google::protobuf::Arena* arena);
  Handover(::google::protobuf::Arena* arena, const Handover& from);
  Handover(::google::protobuf::Arena* arena, Handover&& from) noexcept
      : Handover(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockFieldNumber = 3,
    kIdFieldNumber = 1,
    kReadyFieldNumber = 2,
  };
  // .DynStacking.HotStorage.DataModel.Block Block = 3;
  bool has_block() const;
  void clear_block() ;
  const ::DynStacking::HotStorage::DataModel::Block& block() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::Block* release_block();
  ::DynStacking::HotStorage::DataModel::Block* mutable_block();
  void set_allocated_block(::DynStacking::HotStorage::DataModel::Block* value);
  void unsafe_arena_set_allocated_block(::DynStacking::HotStorage::DataModel::Block* value);
  ::DynStacking::HotStorage::DataModel::Block* unsafe_arena_release_block();

  private:
  const ::DynStacking::HotStorage::DataModel::Block& _internal_block() const;
  ::DynStacking::HotStorage::DataModel::Block* _internal_mutable_block();

  public:
  // int32 Id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool Ready = 2;
  void clear_ready() ;
  bool ready() const;
  void set_ready(bool value);

  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.Handover)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Handover& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DynStacking::HotStorage::DataModel::Block* block_;
    ::int32_t id_;
    bool ready_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Crane final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.Crane) */ {
 public:
  inline Crane() : Crane(nullptr) {}
  ~Crane() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Crane* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Crane));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Crane(
      ::google::protobuf::internal::ConstantInitialized);

  inline Crane(const Crane& from) : Crane(nullptr, from) {}
  inline Crane(Crane&& from) noexcept
      : Crane(nullptr, std::move(from)) {}
  inline Crane& operator=(const Crane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Crane& operator=(Crane&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Crane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Crane* internal_default_instance() {
    return reinterpret_cast<const Crane*>(
        &_Crane_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Crane& a, Crane& b) { a.Swap(&b); }
  inline void Swap(Crane* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Crane* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Crane* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Crane>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Crane& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Crane& from) { Crane::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Crane* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.Crane"; }

 protected:
  explicit Crane(::google::protobuf::Arena* arena);
  Crane(::google::protobuf::Arena* arena, const Crane& from);
  Crane(::google::protobuf::Arena* arena, Crane&& from) noexcept
      : Crane(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLoadFieldNumber = 3,
    kScheduleFieldNumber = 4,
    kIdFieldNumber = 1,
    kLocationIdFieldNumber = 2,
    kGirderPositionFieldNumber = 5,
    kHoistPositionFieldNumber = 6,
  };
  // .DynStacking.HotStorage.DataModel.Block Load = 3;
  bool has_load() const;
  void clear_load() ;
  const ::DynStacking::HotStorage::DataModel::Block& load() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::Block* release_load();
  ::DynStacking::HotStorage::DataModel::Block* mutable_load();
  void set_allocated_load(::DynStacking::HotStorage::DataModel::Block* value);
  void unsafe_arena_set_allocated_load(::DynStacking::HotStorage::DataModel::Block* value);
  ::DynStacking::HotStorage::DataModel::Block* unsafe_arena_release_load();

  private:
  const ::DynStacking::HotStorage::DataModel::Block& _internal_load() const;
  ::DynStacking::HotStorage::DataModel::Block* _internal_mutable_load();

  public:
  // .DynStacking.HotStorage.DataModel.CraneSchedule Schedule = 4;
  bool has_schedule() const;
  void clear_schedule() ;
  const ::DynStacking::HotStorage::DataModel::CraneSchedule& schedule() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::CraneSchedule* release_schedule();
  ::DynStacking::HotStorage::DataModel::CraneSchedule* mutable_schedule();
  void set_allocated_schedule(::DynStacking::HotStorage::DataModel::CraneSchedule* value);
  void unsafe_arena_set_allocated_schedule(::DynStacking::HotStorage::DataModel::CraneSchedule* value);
  ::DynStacking::HotStorage::DataModel::CraneSchedule* unsafe_arena_release_schedule();

  private:
  const ::DynStacking::HotStorage::DataModel::CraneSchedule& _internal_schedule() const;
  ::DynStacking::HotStorage::DataModel::CraneSchedule* _internal_mutable_schedule();

  public:
  // int32 Id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 LocationId = 2;
  void clear_locationid() ;
  ::int32_t locationid() const;
  void set_locationid(::int32_t value);

  private:
  ::int32_t _internal_locationid() const;
  void _internal_set_locationid(::int32_t value);

  public:
  // double GirderPosition = 5;
  void clear_girderposition() ;
  double girderposition() const;
  void set_girderposition(double value);

  private:
  double _internal_girderposition() const;
  void _internal_set_girderposition(double value);

  public:
  // double HoistPosition = 6;
  void clear_hoistposition() ;
  double hoistposition() const;
  void set_hoistposition(double value);

  private:
  double _internal_hoistposition() const;
  void _internal_set_hoistposition(double value);

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.Crane)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Crane& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DynStacking::HotStorage::DataModel::Block* load_;
    ::DynStacking::HotStorage::DataModel::CraneSchedule* schedule_;
    ::int32_t id_;
    ::int32_t locationid_;
    double girderposition_;
    double hoistposition_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class World final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DynStacking.HotStorage.DataModel.World) */ {
 public:
  inline World() : World(nullptr) {}
  ~World() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(World* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(World));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR World(
      ::google::protobuf::internal::ConstantInitialized);

  inline World(const World& from) : World(nullptr, from) {}
  inline World(World&& from) noexcept
      : World(nullptr, std::move(from)) {}
  inline World& operator=(const World& from) {
    CopyFrom(from);
    return *this;
  }
  inline World& operator=(World&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const World& default_instance() {
    return *internal_default_instance();
  }
  static inline const World* internal_default_instance() {
    return reinterpret_cast<const World*>(
        &_World_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(World& a, World& b) { a.Swap(&b); }
  inline void Swap(World* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(World* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  World* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<World>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const World& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const World& from) { World::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(World* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DynStacking.HotStorage.DataModel.World"; }

 protected:
  explicit World(::google::protobuf::Arena* arena);
  World(::google::protobuf::Arena* arena, const World& from);
  World(::google::protobuf::Arena* arena, World&& from) noexcept
      : World(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBuffersFieldNumber = 3,
    kInvalidMovesFieldNumber = 8,
    kNowFieldNumber = 1,
    kProductionFieldNumber = 2,
    kHandoverFieldNumber = 4,
    kCraneFieldNumber = 5,
    kKPIsFieldNumber = 6,
    kObservationDataFieldNumber = 7,
  };
  // repeated .DynStacking.HotStorage.DataModel.Stack Buffers = 3;
  int buffers_size() const;
  private:
  int _internal_buffers_size() const;

  public:
  void clear_buffers() ;
  ::DynStacking::HotStorage::DataModel::Stack* mutable_buffers(int index);
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>* mutable_buffers();

  private:
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>& _internal_buffers() const;
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>* _internal_mutable_buffers();
  public:
  const ::DynStacking::HotStorage::DataModel::Stack& buffers(int index) const;
  ::DynStacking::HotStorage::DataModel::Stack* add_buffers();
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>& buffers() const;
  // repeated .DynStacking.HotStorage.DataModel.CraneMove InvalidMoves = 8;
  int invalidmoves_size() const;
  private:
  int _internal_invalidmoves_size() const;

  public:
  void clear_invalidmoves() ;
  ::DynStacking::HotStorage::DataModel::CraneMove* mutable_invalidmoves(int index);
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>* mutable_invalidmoves();

  private:
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>& _internal_invalidmoves() const;
  ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>* _internal_mutable_invalidmoves();
  public:
  const ::DynStacking::HotStorage::DataModel::CraneMove& invalidmoves(int index) const;
  ::DynStacking::HotStorage::DataModel::CraneMove* add_invalidmoves();
  const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>& invalidmoves() const;
  // .DynStacking.HotStorage.DataModel.TimeStamp Now = 1;
  bool has_now() const;
  void clear_now() ;
  const ::DynStacking::HotStorage::DataModel::TimeStamp& now() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::TimeStamp* release_now();
  ::DynStacking::HotStorage::DataModel::TimeStamp* mutable_now();
  void set_allocated_now(::DynStacking::HotStorage::DataModel::TimeStamp* value);
  void unsafe_arena_set_allocated_now(::DynStacking::HotStorage::DataModel::TimeStamp* value);
  ::DynStacking::HotStorage::DataModel::TimeStamp* unsafe_arena_release_now();

  private:
  const ::DynStacking::HotStorage::DataModel::TimeStamp& _internal_now() const;
  ::DynStacking::HotStorage::DataModel::TimeStamp* _internal_mutable_now();

  public:
  // .DynStacking.HotStorage.DataModel.Stack Production = 2;
  bool has_production() const;
  void clear_production() ;
  const ::DynStacking::HotStorage::DataModel::Stack& production() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::Stack* release_production();
  ::DynStacking::HotStorage::DataModel::Stack* mutable_production();
  void set_allocated_production(::DynStacking::HotStorage::DataModel::Stack* value);
  void unsafe_arena_set_allocated_production(::DynStacking::HotStorage::DataModel::Stack* value);
  ::DynStacking::HotStorage::DataModel::Stack* unsafe_arena_release_production();

  private:
  const ::DynStacking::HotStorage::DataModel::Stack& _internal_production() const;
  ::DynStacking::HotStorage::DataModel::Stack* _internal_mutable_production();

  public:
  // .DynStacking.HotStorage.DataModel.Handover Handover = 4;
  bool has_handover() const;
  void clear_handover() ;
  const ::DynStacking::HotStorage::DataModel::Handover& handover() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::Handover* release_handover();
  ::DynStacking::HotStorage::DataModel::Handover* mutable_handover();
  void set_allocated_handover(::DynStacking::HotStorage::DataModel::Handover* value);
  void unsafe_arena_set_allocated_handover(::DynStacking::HotStorage::DataModel::Handover* value);
  ::DynStacking::HotStorage::DataModel::Handover* unsafe_arena_release_handover();

  private:
  const ::DynStacking::HotStorage::DataModel::Handover& _internal_handover() const;
  ::DynStacking::HotStorage::DataModel::Handover* _internal_mutable_handover();

  public:
  // .DynStacking.HotStorage.DataModel.Crane Crane = 5;
  bool has_crane() const;
  void clear_crane() ;
  const ::DynStacking::HotStorage::DataModel::Crane& crane() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::Crane* release_crane();
  ::DynStacking::HotStorage::DataModel::Crane* mutable_crane();
  void set_allocated_crane(::DynStacking::HotStorage::DataModel::Crane* value);
  void unsafe_arena_set_allocated_crane(::DynStacking::HotStorage::DataModel::Crane* value);
  ::DynStacking::HotStorage::DataModel::Crane* unsafe_arena_release_crane();

  private:
  const ::DynStacking::HotStorage::DataModel::Crane& _internal_crane() const;
  ::DynStacking::HotStorage::DataModel::Crane* _internal_mutable_crane();

  public:
  // .DynStacking.HotStorage.DataModel.Performance KPIs = 6;
  bool has_kpis() const;
  void clear_kpis() ;
  const ::DynStacking::HotStorage::DataModel::Performance& kpis() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::Performance* release_kpis();
  ::DynStacking::HotStorage::DataModel::Performance* mutable_kpis();
  void set_allocated_kpis(::DynStacking::HotStorage::DataModel::Performance* value);
  void unsafe_arena_set_allocated_kpis(::DynStacking::HotStorage::DataModel::Performance* value);
  ::DynStacking::HotStorage::DataModel::Performance* unsafe_arena_release_kpis();

  private:
  const ::DynStacking::HotStorage::DataModel::Performance& _internal_kpis() const;
  ::DynStacking::HotStorage::DataModel::Performance* _internal_mutable_kpis();

  public:
  // .DynStacking.HotStorage.DataModel.Uncertainties ObservationData = 7;
  bool has_observationdata() const;
  void clear_observationdata() ;
  const ::DynStacking::HotStorage::DataModel::Uncertainties& observationdata() const;
  PROTOBUF_NODISCARD ::DynStacking::HotStorage::DataModel::Uncertainties* release_observationdata();
  ::DynStacking::HotStorage::DataModel::Uncertainties* mutable_observationdata();
  void set_allocated_observationdata(::DynStacking::HotStorage::DataModel::Uncertainties* value);
  void unsafe_arena_set_allocated_observationdata(::DynStacking::HotStorage::DataModel::Uncertainties* value);
  ::DynStacking::HotStorage::DataModel::Uncertainties* unsafe_arena_release_observationdata();

  private:
  const ::DynStacking::HotStorage::DataModel::Uncertainties& _internal_observationdata() const;
  ::DynStacking::HotStorage::DataModel::Uncertainties* _internal_mutable_observationdata();

  public:
  // @@protoc_insertion_point(class_scope:DynStacking.HotStorage.DataModel.World)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 8,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const World& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DynStacking::HotStorage::DataModel::Stack > buffers_;
    ::google::protobuf::RepeatedPtrField< ::DynStacking::HotStorage::DataModel::CraneMove > invalidmoves_;
    ::DynStacking::HotStorage::DataModel::TimeStamp* now_;
    ::DynStacking::HotStorage::DataModel::Stack* production_;
    ::DynStacking::HotStorage::DataModel::Handover* handover_;
    ::DynStacking::HotStorage::DataModel::Crane* crane_;
    ::DynStacking::HotStorage::DataModel::Performance* kpis_;
    ::DynStacking::HotStorage::DataModel::Uncertainties* observationdata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotstorage_5fmodel_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Block

// int32 Id = 1;
inline void Block::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t Block::id() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Block.Id)
  return _internal_id();
}
inline void Block::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Block.Id)
}
inline ::int32_t Block::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Block::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .DynStacking.HotStorage.DataModel.TimeStamp Release = 2;
inline bool Block::has_release() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.release_ != nullptr);
  return value;
}
inline void Block::clear_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.release_ != nullptr) _impl_.release_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DynStacking::HotStorage::DataModel::TimeStamp& Block::_internal_release() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::TimeStamp* p = _impl_.release_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::TimeStamp&>(::DynStacking::HotStorage::DataModel::_TimeStamp_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::TimeStamp& Block::release() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Block.Release)
  return _internal_release();
}
inline void Block::unsafe_arena_set_allocated_release(::DynStacking::HotStorage::DataModel::TimeStamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.release_);
  }
  _impl_.release_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.Block.Release)
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::release_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* released = _impl_.release_;
  _impl_.release_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::unsafe_arena_release_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.Block.Release)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* temp = _impl_.release_;
  _impl_.release_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::_internal_mutable_release() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.release_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::TimeStamp>(GetArena());
    _impl_.release_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(p);
  }
  return _impl_.release_;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::mutable_release() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* _msg = _internal_mutable_release();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.Block.Release)
  return _msg;
}
inline void Block::set_allocated_release(::DynStacking::HotStorage::DataModel::TimeStamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.release_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.release_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.Block.Release)
}

// .DynStacking.HotStorage.DataModel.TimeStamp Due = 3;
inline bool Block::has_due() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.due_ != nullptr);
  return value;
}
inline void Block::clear_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.due_ != nullptr) _impl_.due_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DynStacking::HotStorage::DataModel::TimeStamp& Block::_internal_due() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::TimeStamp* p = _impl_.due_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::TimeStamp&>(::DynStacking::HotStorage::DataModel::_TimeStamp_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::TimeStamp& Block::due() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Block.Due)
  return _internal_due();
}
inline void Block::unsafe_arena_set_allocated_due(::DynStacking::HotStorage::DataModel::TimeStamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.due_);
  }
  _impl_.due_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.Block.Due)
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::release_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* released = _impl_.due_;
  _impl_.due_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::unsafe_arena_release_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.Block.Due)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* temp = _impl_.due_;
  _impl_.due_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::_internal_mutable_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.due_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::TimeStamp>(GetArena());
    _impl_.due_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(p);
  }
  return _impl_.due_;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* Block::mutable_due() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* _msg = _internal_mutable_due();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.Block.Due)
  return _msg;
}
inline void Block::set_allocated_due(::DynStacking::HotStorage::DataModel::TimeStamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.due_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.due_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.Block.Due)
}

// bool Ready = 4;
inline void Block::clear_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ready_ = false;
}
inline bool Block::ready() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Block.Ready)
  return _internal_ready();
}
inline void Block::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Block.Ready)
}
inline bool Block::_internal_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ready_;
}
inline void Block::_internal_set_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ready_ = value;
}

// -------------------------------------------------------------------

// Crane

// int32 Id = 1;
inline void Crane::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t Crane::id() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Crane.Id)
  return _internal_id();
}
inline void Crane::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Crane.Id)
}
inline ::int32_t Crane::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Crane::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// int32 LocationId = 2;
inline void Crane::clear_locationid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locationid_ = 0;
}
inline ::int32_t Crane::locationid() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Crane.LocationId)
  return _internal_locationid();
}
inline void Crane::set_locationid(::int32_t value) {
  _internal_set_locationid(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Crane.LocationId)
}
inline ::int32_t Crane::_internal_locationid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.locationid_;
}
inline void Crane::_internal_set_locationid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locationid_ = value;
}

// .DynStacking.HotStorage.DataModel.Block Load = 3;
inline bool Crane::has_load() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.load_ != nullptr);
  return value;
}
inline void Crane::clear_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.load_ != nullptr) _impl_.load_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DynStacking::HotStorage::DataModel::Block& Crane::_internal_load() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::Block* p = _impl_.load_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::Block&>(::DynStacking::HotStorage::DataModel::_Block_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::Block& Crane::load() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Crane.Load)
  return _internal_load();
}
inline void Crane::unsafe_arena_set_allocated_load(::DynStacking::HotStorage::DataModel::Block* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.load_);
  }
  _impl_.load_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Block*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.Crane.Load)
}
inline ::DynStacking::HotStorage::DataModel::Block* Crane::release_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::Block* released = _impl_.load_;
  _impl_.load_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::Block* Crane::unsafe_arena_release_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.Crane.Load)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::Block* temp = _impl_.load_;
  _impl_.load_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::Block* Crane::_internal_mutable_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.load_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::Block>(GetArena());
    _impl_.load_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Block*>(p);
  }
  return _impl_.load_;
}
inline ::DynStacking::HotStorage::DataModel::Block* Crane::mutable_load() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DynStacking::HotStorage::DataModel::Block* _msg = _internal_mutable_load();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.Crane.Load)
  return _msg;
}
inline void Crane::set_allocated_load(::DynStacking::HotStorage::DataModel::Block* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.load_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.load_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Block*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.Crane.Load)
}

// .DynStacking.HotStorage.DataModel.CraneSchedule Schedule = 4;
inline bool Crane::has_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedule_ != nullptr);
  return value;
}
inline void Crane::clear_schedule() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.schedule_ != nullptr) _impl_.schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DynStacking::HotStorage::DataModel::CraneSchedule& Crane::_internal_schedule() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::CraneSchedule* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::CraneSchedule&>(::DynStacking::HotStorage::DataModel::_CraneSchedule_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::CraneSchedule& Crane::schedule() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Crane.Schedule)
  return _internal_schedule();
}
inline void Crane::unsafe_arena_set_allocated_schedule(::DynStacking::HotStorage::DataModel::CraneSchedule* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::CraneSchedule*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.Crane.Schedule)
}
inline ::DynStacking::HotStorage::DataModel::CraneSchedule* Crane::release_schedule() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DynStacking::HotStorage::DataModel::CraneSchedule* released = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::CraneSchedule* Crane::unsafe_arena_release_schedule() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.Crane.Schedule)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DynStacking::HotStorage::DataModel::CraneSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::CraneSchedule* Crane::_internal_mutable_schedule() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.schedule_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::CraneSchedule>(GetArena());
    _impl_.schedule_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::CraneSchedule*>(p);
  }
  return _impl_.schedule_;
}
inline ::DynStacking::HotStorage::DataModel::CraneSchedule* Crane::mutable_schedule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DynStacking::HotStorage::DataModel::CraneSchedule* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.Crane.Schedule)
  return _msg;
}
inline void Crane::set_allocated_schedule(::DynStacking::HotStorage::DataModel::CraneSchedule* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.schedule_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.schedule_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::CraneSchedule*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.Crane.Schedule)
}

// double GirderPosition = 5;
inline void Crane::clear_girderposition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.girderposition_ = 0;
}
inline double Crane::girderposition() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Crane.GirderPosition)
  return _internal_girderposition();
}
inline void Crane::set_girderposition(double value) {
  _internal_set_girderposition(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Crane.GirderPosition)
}
inline double Crane::_internal_girderposition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.girderposition_;
}
inline void Crane::_internal_set_girderposition(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.girderposition_ = value;
}

// double HoistPosition = 6;
inline void Crane::clear_hoistposition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hoistposition_ = 0;
}
inline double Crane::hoistposition() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Crane.HoistPosition)
  return _internal_hoistposition();
}
inline void Crane::set_hoistposition(double value) {
  _internal_set_hoistposition(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Crane.HoistPosition)
}
inline double Crane::_internal_hoistposition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hoistposition_;
}
inline void Crane::_internal_set_hoistposition(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hoistposition_ = value;
}

// -------------------------------------------------------------------

// CraneMove

// int32 BlockId = 1;
inline void CraneMove::clear_blockid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockid_ = 0;
}
inline ::int32_t CraneMove::blockid() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.CraneMove.BlockId)
  return _internal_blockid();
}
inline void CraneMove::set_blockid(::int32_t value) {
  _internal_set_blockid(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.CraneMove.BlockId)
}
inline ::int32_t CraneMove::_internal_blockid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blockid_;
}
inline void CraneMove::_internal_set_blockid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockid_ = value;
}

// int32 SourceId = 2;
inline void CraneMove::clear_sourceid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sourceid_ = 0;
}
inline ::int32_t CraneMove::sourceid() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.CraneMove.SourceId)
  return _internal_sourceid();
}
inline void CraneMove::set_sourceid(::int32_t value) {
  _internal_set_sourceid(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.CraneMove.SourceId)
}
inline ::int32_t CraneMove::_internal_sourceid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sourceid_;
}
inline void CraneMove::_internal_set_sourceid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sourceid_ = value;
}

// int32 TargetId = 3;
inline void CraneMove::clear_targetid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targetid_ = 0;
}
inline ::int32_t CraneMove::targetid() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.CraneMove.TargetId)
  return _internal_targetid();
}
inline void CraneMove::set_targetid(::int32_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.CraneMove.TargetId)
}
inline ::int32_t CraneMove::_internal_targetid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targetid_;
}
inline void CraneMove::_internal_set_targetid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targetid_ = value;
}

// int32 Sequence = 4;
inline void CraneMove::clear_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_ = 0;
}
inline ::int32_t CraneMove::sequence() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.CraneMove.Sequence)
  return _internal_sequence();
}
inline void CraneMove::set_sequence(::int32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.CraneMove.Sequence)
}
inline ::int32_t CraneMove::_internal_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sequence_;
}
inline void CraneMove::_internal_set_sequence(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_ = value;
}

// bool EmptyMove = 5;
inline void CraneMove::clear_emptymove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emptymove_ = false;
}
inline bool CraneMove::emptymove() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.CraneMove.EmptyMove)
  return _internal_emptymove();
}
inline void CraneMove::set_emptymove(bool value) {
  _internal_set_emptymove(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.CraneMove.EmptyMove)
}
inline bool CraneMove::_internal_emptymove() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.emptymove_;
}
inline void CraneMove::_internal_set_emptymove(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emptymove_ = value;
}

// -------------------------------------------------------------------

// CraneSchedule

// repeated .DynStacking.HotStorage.DataModel.CraneMove Moves = 1;
inline int CraneSchedule::_internal_moves_size() const {
  return _internal_moves().size();
}
inline int CraneSchedule::moves_size() const {
  return _internal_moves_size();
}
inline void CraneSchedule::clear_moves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.moves_.Clear();
}
inline ::DynStacking::HotStorage::DataModel::CraneMove* CraneSchedule::mutable_moves(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.CraneSchedule.Moves)
  return _internal_mutable_moves()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>* CraneSchedule::mutable_moves()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DynStacking.HotStorage.DataModel.CraneSchedule.Moves)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_moves();
}
inline const ::DynStacking::HotStorage::DataModel::CraneMove& CraneSchedule::moves(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.CraneSchedule.Moves)
  return _internal_moves().Get(index);
}
inline ::DynStacking::HotStorage::DataModel::CraneMove* CraneSchedule::add_moves() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DynStacking::HotStorage::DataModel::CraneMove* _add = _internal_mutable_moves()->Add();
  // @@protoc_insertion_point(field_add:DynStacking.HotStorage.DataModel.CraneSchedule.Moves)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>& CraneSchedule::moves() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DynStacking.HotStorage.DataModel.CraneSchedule.Moves)
  return _internal_moves();
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>&
CraneSchedule::_internal_moves() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.moves_;
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>*
CraneSchedule::_internal_mutable_moves() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.moves_;
}

// int32 SequenceNr = 2;
inline void CraneSchedule::clear_sequencenr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencenr_ = 0;
}
inline ::int32_t CraneSchedule::sequencenr() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.CraneSchedule.SequenceNr)
  return _internal_sequencenr();
}
inline void CraneSchedule::set_sequencenr(::int32_t value) {
  _internal_set_sequencenr(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.CraneSchedule.SequenceNr)
}
inline ::int32_t CraneSchedule::_internal_sequencenr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sequencenr_;
}
inline void CraneSchedule::_internal_set_sequencenr(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencenr_ = value;
}

// -------------------------------------------------------------------

// Handover

// int32 Id = 1;
inline void Handover::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t Handover::id() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Handover.Id)
  return _internal_id();
}
inline void Handover::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Handover.Id)
}
inline ::int32_t Handover::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Handover::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// bool Ready = 2;
inline void Handover::clear_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ready_ = false;
}
inline bool Handover::ready() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Handover.Ready)
  return _internal_ready();
}
inline void Handover::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Handover.Ready)
}
inline bool Handover::_internal_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ready_;
}
inline void Handover::_internal_set_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ready_ = value;
}

// .DynStacking.HotStorage.DataModel.Block Block = 3;
inline bool Handover::has_block() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_ != nullptr);
  return value;
}
inline void Handover::clear_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_ != nullptr) _impl_.block_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DynStacking::HotStorage::DataModel::Block& Handover::_internal_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::Block* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::Block&>(::DynStacking::HotStorage::DataModel::_Block_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::Block& Handover::block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Handover.Block)
  return _internal_block();
}
inline void Handover::unsafe_arena_set_allocated_block(::DynStacking::HotStorage::DataModel::Block* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Block*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.Handover.Block)
}
inline ::DynStacking::HotStorage::DataModel::Block* Handover::release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::Block* released = _impl_.block_;
  _impl_.block_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::Block* Handover::unsafe_arena_release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.Handover.Block)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::Block* Handover::_internal_mutable_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::Block>(GetArena());
    _impl_.block_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Block*>(p);
  }
  return _impl_.block_;
}
inline ::DynStacking::HotStorage::DataModel::Block* Handover::mutable_block() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DynStacking::HotStorage::DataModel::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.Handover.Block)
  return _msg;
}
inline void Handover::set_allocated_block(::DynStacking::HotStorage::DataModel::Block* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.block_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.block_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Block*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.Handover.Block)
}

// -------------------------------------------------------------------

// Performance

// int32 CraneManipulations = 1;
inline void Performance::clear_cranemanipulations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cranemanipulations_ = 0;
}
inline ::int32_t Performance::cranemanipulations() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.CraneManipulations)
  return _internal_cranemanipulations();
}
inline void Performance::set_cranemanipulations(::int32_t value) {
  _internal_set_cranemanipulations(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.CraneManipulations)
}
inline ::int32_t Performance::_internal_cranemanipulations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cranemanipulations_;
}
inline void Performance::_internal_set_cranemanipulations(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cranemanipulations_ = value;
}

// double ServiceLevelMean = 2;
inline void Performance::clear_servicelevelmean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.servicelevelmean_ = 0;
}
inline double Performance::servicelevelmean() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.ServiceLevelMean)
  return _internal_servicelevelmean();
}
inline void Performance::set_servicelevelmean(double value) {
  _internal_set_servicelevelmean(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.ServiceLevelMean)
}
inline double Performance::_internal_servicelevelmean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.servicelevelmean_;
}
inline void Performance::_internal_set_servicelevelmean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.servicelevelmean_ = value;
}

// double LeadTimeMean = 3;
inline void Performance::clear_leadtimemean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leadtimemean_ = 0;
}
inline double Performance::leadtimemean() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.LeadTimeMean)
  return _internal_leadtimemean();
}
inline void Performance::set_leadtimemean(double value) {
  _internal_set_leadtimemean(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.LeadTimeMean)
}
inline double Performance::_internal_leadtimemean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.leadtimemean_;
}
inline void Performance::_internal_set_leadtimemean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leadtimemean_ = value;
}

// int32 DeliveredBlocks = 4;
inline void Performance::clear_deliveredblocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deliveredblocks_ = 0;
}
inline ::int32_t Performance::deliveredblocks() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.DeliveredBlocks)
  return _internal_deliveredblocks();
}
inline void Performance::set_deliveredblocks(::int32_t value) {
  _internal_set_deliveredblocks(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.DeliveredBlocks)
}
inline ::int32_t Performance::_internal_deliveredblocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.deliveredblocks_;
}
inline void Performance::_internal_set_deliveredblocks(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deliveredblocks_ = value;
}

// int32 TotalBlocksOnTime = 5;
inline void Performance::clear_totalblocksontime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.totalblocksontime_ = 0;
}
inline ::int32_t Performance::totalblocksontime() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.TotalBlocksOnTime)
  return _internal_totalblocksontime();
}
inline void Performance::set_totalblocksontime(::int32_t value) {
  _internal_set_totalblocksontime(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.TotalBlocksOnTime)
}
inline ::int32_t Performance::_internal_totalblocksontime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.totalblocksontime_;
}
inline void Performance::_internal_set_totalblocksontime(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.totalblocksontime_ = value;
}

// double BlockedArrivalTime = 6;
inline void Performance::clear_blockedarrivaltime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockedarrivaltime_ = 0;
}
inline double Performance::blockedarrivaltime() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.BlockedArrivalTime)
  return _internal_blockedarrivaltime();
}
inline void Performance::set_blockedarrivaltime(double value) {
  _internal_set_blockedarrivaltime(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.BlockedArrivalTime)
}
inline double Performance::_internal_blockedarrivaltime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blockedarrivaltime_;
}
inline void Performance::_internal_set_blockedarrivaltime(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockedarrivaltime_ = value;
}

// double TardinessMean = 7;
inline void Performance::clear_tardinessmean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tardinessmean_ = 0;
}
inline double Performance::tardinessmean() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.TardinessMean)
  return _internal_tardinessmean();
}
inline void Performance::set_tardinessmean(double value) {
  _internal_set_tardinessmean(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.TardinessMean)
}
inline double Performance::_internal_tardinessmean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tardinessmean_;
}
inline void Performance::_internal_set_tardinessmean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tardinessmean_ = value;
}

// double BufferUtilizationMean = 8;
inline void Performance::clear_bufferutilizationmean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bufferutilizationmean_ = 0;
}
inline double Performance::bufferutilizationmean() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.BufferUtilizationMean)
  return _internal_bufferutilizationmean();
}
inline void Performance::set_bufferutilizationmean(double value) {
  _internal_set_bufferutilizationmean(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.BufferUtilizationMean)
}
inline double Performance::_internal_bufferutilizationmean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bufferutilizationmean_;
}
inline void Performance::_internal_set_bufferutilizationmean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bufferutilizationmean_ = value;
}

// double CraneUtilizationMean = 9;
inline void Performance::clear_craneutilizationmean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.craneutilizationmean_ = 0;
}
inline double Performance::craneutilizationmean() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.CraneUtilizationMean)
  return _internal_craneutilizationmean();
}
inline void Performance::set_craneutilizationmean(double value) {
  _internal_set_craneutilizationmean(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.CraneUtilizationMean)
}
inline double Performance::_internal_craneutilizationmean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.craneutilizationmean_;
}
inline void Performance::_internal_set_craneutilizationmean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.craneutilizationmean_ = value;
}

// double HandoverUtilizationMean = 10;
inline void Performance::clear_handoverutilizationmean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handoverutilizationmean_ = 0;
}
inline double Performance::handoverutilizationmean() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.HandoverUtilizationMean)
  return _internal_handoverutilizationmean();
}
inline void Performance::set_handoverutilizationmean(double value) {
  _internal_set_handoverutilizationmean(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.HandoverUtilizationMean)
}
inline double Performance::_internal_handoverutilizationmean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.handoverutilizationmean_;
}
inline void Performance::_internal_set_handoverutilizationmean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handoverutilizationmean_ = value;
}

// double UpstreamUtilizationMean = 11;
inline void Performance::clear_upstreamutilizationmean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.upstreamutilizationmean_ = 0;
}
inline double Performance::upstreamutilizationmean() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Performance.UpstreamUtilizationMean)
  return _internal_upstreamutilizationmean();
}
inline void Performance::set_upstreamutilizationmean(double value) {
  _internal_set_upstreamutilizationmean(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Performance.UpstreamUtilizationMean)
}
inline double Performance::_internal_upstreamutilizationmean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.upstreamutilizationmean_;
}
inline void Performance::_internal_set_upstreamutilizationmean(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.upstreamutilizationmean_ = value;
}

// -------------------------------------------------------------------

// Stack

// int32 Id = 1;
inline void Stack::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t Stack::id() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Stack.Id)
  return _internal_id();
}
inline void Stack::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Stack.Id)
}
inline ::int32_t Stack::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Stack::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// int32 MaxHeight = 2;
inline void Stack::clear_maxheight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maxheight_ = 0;
}
inline ::int32_t Stack::maxheight() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Stack.MaxHeight)
  return _internal_maxheight();
}
inline void Stack::set_maxheight(::int32_t value) {
  _internal_set_maxheight(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Stack.MaxHeight)
}
inline ::int32_t Stack::_internal_maxheight() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maxheight_;
}
inline void Stack::_internal_set_maxheight(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maxheight_ = value;
}

// repeated .DynStacking.HotStorage.DataModel.Block BottomToTop = 3;
inline int Stack::_internal_bottomtotop_size() const {
  return _internal_bottomtotop().size();
}
inline int Stack::bottomtotop_size() const {
  return _internal_bottomtotop_size();
}
inline void Stack::clear_bottomtotop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bottomtotop_.Clear();
}
inline ::DynStacking::HotStorage::DataModel::Block* Stack::mutable_bottomtotop(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.Stack.BottomToTop)
  return _internal_mutable_bottomtotop()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>* Stack::mutable_bottomtotop()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DynStacking.HotStorage.DataModel.Stack.BottomToTop)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bottomtotop();
}
inline const ::DynStacking::HotStorage::DataModel::Block& Stack::bottomtotop(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Stack.BottomToTop)
  return _internal_bottomtotop().Get(index);
}
inline ::DynStacking::HotStorage::DataModel::Block* Stack::add_bottomtotop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DynStacking::HotStorage::DataModel::Block* _add = _internal_mutable_bottomtotop()->Add();
  // @@protoc_insertion_point(field_add:DynStacking.HotStorage.DataModel.Stack.BottomToTop)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>& Stack::bottomtotop() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DynStacking.HotStorage.DataModel.Stack.BottomToTop)
  return _internal_bottomtotop();
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>&
Stack::_internal_bottomtotop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bottomtotop_;
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Block>*
Stack::_internal_mutable_bottomtotop() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bottomtotop_;
}

// -------------------------------------------------------------------

// TimeStamp

// int64 MilliSeconds = 1;
inline void TimeStamp::clear_milliseconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.milliseconds_ = ::int64_t{0};
}
inline ::int64_t TimeStamp::milliseconds() const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.TimeStamp.MilliSeconds)
  return _internal_milliseconds();
}
inline void TimeStamp::set_milliseconds(::int64_t value) {
  _internal_set_milliseconds(value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.TimeStamp.MilliSeconds)
}
inline ::int64_t TimeStamp::_internal_milliseconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.milliseconds_;
}
inline void TimeStamp::_internal_set_milliseconds(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.milliseconds_ = value;
}

// -------------------------------------------------------------------

// Uncertainties

// repeated double ArrivalIntervals = 1 [packed = false];
inline int Uncertainties::_internal_arrivalintervals_size() const {
  return _internal_arrivalintervals().size();
}
inline int Uncertainties::arrivalintervals_size() const {
  return _internal_arrivalintervals_size();
}
inline void Uncertainties::clear_arrivalintervals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arrivalintervals_.Clear();
}
inline double Uncertainties::arrivalintervals(int index) const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Uncertainties.ArrivalIntervals)
  return _internal_arrivalintervals().Get(index);
}
inline void Uncertainties::set_arrivalintervals(int index, double value) {
  _internal_mutable_arrivalintervals()->Set(index, value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Uncertainties.ArrivalIntervals)
}
inline void Uncertainties::add_arrivalintervals(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_arrivalintervals()->Add(value);
  // @@protoc_insertion_point(field_add:DynStacking.HotStorage.DataModel.Uncertainties.ArrivalIntervals)
}
inline const ::google::protobuf::RepeatedField<double>& Uncertainties::arrivalintervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DynStacking.HotStorage.DataModel.Uncertainties.ArrivalIntervals)
  return _internal_arrivalintervals();
}
inline ::google::protobuf::RepeatedField<double>* Uncertainties::mutable_arrivalintervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DynStacking.HotStorage.DataModel.Uncertainties.ArrivalIntervals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arrivalintervals();
}
inline const ::google::protobuf::RepeatedField<double>&
Uncertainties::_internal_arrivalintervals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arrivalintervals_;
}
inline ::google::protobuf::RepeatedField<double>* Uncertainties::_internal_mutable_arrivalintervals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arrivalintervals_;
}

// repeated double CraneMoveTimes = 2 [packed = false];
inline int Uncertainties::_internal_cranemovetimes_size() const {
  return _internal_cranemovetimes().size();
}
inline int Uncertainties::cranemovetimes_size() const {
  return _internal_cranemovetimes_size();
}
inline void Uncertainties::clear_cranemovetimes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cranemovetimes_.Clear();
}
inline double Uncertainties::cranemovetimes(int index) const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Uncertainties.CraneMoveTimes)
  return _internal_cranemovetimes().Get(index);
}
inline void Uncertainties::set_cranemovetimes(int index, double value) {
  _internal_mutable_cranemovetimes()->Set(index, value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Uncertainties.CraneMoveTimes)
}
inline void Uncertainties::add_cranemovetimes(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_cranemovetimes()->Add(value);
  // @@protoc_insertion_point(field_add:DynStacking.HotStorage.DataModel.Uncertainties.CraneMoveTimes)
}
inline const ::google::protobuf::RepeatedField<double>& Uncertainties::cranemovetimes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DynStacking.HotStorage.DataModel.Uncertainties.CraneMoveTimes)
  return _internal_cranemovetimes();
}
inline ::google::protobuf::RepeatedField<double>* Uncertainties::mutable_cranemovetimes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DynStacking.HotStorage.DataModel.Uncertainties.CraneMoveTimes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cranemovetimes();
}
inline const ::google::protobuf::RepeatedField<double>&
Uncertainties::_internal_cranemovetimes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cranemovetimes_;
}
inline ::google::protobuf::RepeatedField<double>* Uncertainties::_internal_mutable_cranemovetimes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cranemovetimes_;
}

// repeated double HandoverReadyIntervals = 3 [packed = false];
inline int Uncertainties::_internal_handoverreadyintervals_size() const {
  return _internal_handoverreadyintervals().size();
}
inline int Uncertainties::handoverreadyintervals_size() const {
  return _internal_handoverreadyintervals_size();
}
inline void Uncertainties::clear_handoverreadyintervals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.handoverreadyintervals_.Clear();
}
inline double Uncertainties::handoverreadyintervals(int index) const {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.Uncertainties.HandoverReadyIntervals)
  return _internal_handoverreadyintervals().Get(index);
}
inline void Uncertainties::set_handoverreadyintervals(int index, double value) {
  _internal_mutable_handoverreadyintervals()->Set(index, value);
  // @@protoc_insertion_point(field_set:DynStacking.HotStorage.DataModel.Uncertainties.HandoverReadyIntervals)
}
inline void Uncertainties::add_handoverreadyintervals(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_handoverreadyintervals()->Add(value);
  // @@protoc_insertion_point(field_add:DynStacking.HotStorage.DataModel.Uncertainties.HandoverReadyIntervals)
}
inline const ::google::protobuf::RepeatedField<double>& Uncertainties::handoverreadyintervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DynStacking.HotStorage.DataModel.Uncertainties.HandoverReadyIntervals)
  return _internal_handoverreadyintervals();
}
inline ::google::protobuf::RepeatedField<double>* Uncertainties::mutable_handoverreadyintervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DynStacking.HotStorage.DataModel.Uncertainties.HandoverReadyIntervals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_handoverreadyintervals();
}
inline const ::google::protobuf::RepeatedField<double>&
Uncertainties::_internal_handoverreadyintervals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.handoverreadyintervals_;
}
inline ::google::protobuf::RepeatedField<double>* Uncertainties::_internal_mutable_handoverreadyintervals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.handoverreadyintervals_;
}

// -------------------------------------------------------------------

// World

// .DynStacking.HotStorage.DataModel.TimeStamp Now = 1;
inline bool World::has_now() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.now_ != nullptr);
  return value;
}
inline void World::clear_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.now_ != nullptr) _impl_.now_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DynStacking::HotStorage::DataModel::TimeStamp& World::_internal_now() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::TimeStamp* p = _impl_.now_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::TimeStamp&>(::DynStacking::HotStorage::DataModel::_TimeStamp_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::TimeStamp& World::now() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.Now)
  return _internal_now();
}
inline void World::unsafe_arena_set_allocated_now(::DynStacking::HotStorage::DataModel::TimeStamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.now_);
  }
  _impl_.now_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.World.Now)
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* World::release_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* released = _impl_.now_;
  _impl_.now_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* World::unsafe_arena_release_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.World.Now)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* temp = _impl_.now_;
  _impl_.now_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* World::_internal_mutable_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.now_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::TimeStamp>(GetArena());
    _impl_.now_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(p);
  }
  return _impl_.now_;
}
inline ::DynStacking::HotStorage::DataModel::TimeStamp* World::mutable_now() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DynStacking::HotStorage::DataModel::TimeStamp* _msg = _internal_mutable_now();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.Now)
  return _msg;
}
inline void World::set_allocated_now(::DynStacking::HotStorage::DataModel::TimeStamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.now_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.now_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::TimeStamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.World.Now)
}

// .DynStacking.HotStorage.DataModel.Stack Production = 2;
inline bool World::has_production() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.production_ != nullptr);
  return value;
}
inline void World::clear_production() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.production_ != nullptr) _impl_.production_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DynStacking::HotStorage::DataModel::Stack& World::_internal_production() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::Stack* p = _impl_.production_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::Stack&>(::DynStacking::HotStorage::DataModel::_Stack_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::Stack& World::production() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.Production)
  return _internal_production();
}
inline void World::unsafe_arena_set_allocated_production(::DynStacking::HotStorage::DataModel::Stack* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.production_);
  }
  _impl_.production_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Stack*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.World.Production)
}
inline ::DynStacking::HotStorage::DataModel::Stack* World::release_production() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DynStacking::HotStorage::DataModel::Stack* released = _impl_.production_;
  _impl_.production_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::Stack* World::unsafe_arena_release_production() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.World.Production)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DynStacking::HotStorage::DataModel::Stack* temp = _impl_.production_;
  _impl_.production_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::Stack* World::_internal_mutable_production() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.production_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::Stack>(GetArena());
    _impl_.production_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Stack*>(p);
  }
  return _impl_.production_;
}
inline ::DynStacking::HotStorage::DataModel::Stack* World::mutable_production() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::DynStacking::HotStorage::DataModel::Stack* _msg = _internal_mutable_production();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.Production)
  return _msg;
}
inline void World::set_allocated_production(::DynStacking::HotStorage::DataModel::Stack* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.production_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.production_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Stack*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.World.Production)
}

// repeated .DynStacking.HotStorage.DataModel.Stack Buffers = 3;
inline int World::_internal_buffers_size() const {
  return _internal_buffers().size();
}
inline int World::buffers_size() const {
  return _internal_buffers_size();
}
inline void World::clear_buffers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buffers_.Clear();
}
inline ::DynStacking::HotStorage::DataModel::Stack* World::mutable_buffers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.Buffers)
  return _internal_mutable_buffers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>* World::mutable_buffers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DynStacking.HotStorage.DataModel.World.Buffers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_buffers();
}
inline const ::DynStacking::HotStorage::DataModel::Stack& World::buffers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.Buffers)
  return _internal_buffers().Get(index);
}
inline ::DynStacking::HotStorage::DataModel::Stack* World::add_buffers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DynStacking::HotStorage::DataModel::Stack* _add = _internal_mutable_buffers()->Add();
  // @@protoc_insertion_point(field_add:DynStacking.HotStorage.DataModel.World.Buffers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>& World::buffers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DynStacking.HotStorage.DataModel.World.Buffers)
  return _internal_buffers();
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>&
World::_internal_buffers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buffers_;
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::Stack>*
World::_internal_mutable_buffers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.buffers_;
}

// .DynStacking.HotStorage.DataModel.Handover Handover = 4;
inline bool World::has_handover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handover_ != nullptr);
  return value;
}
inline void World::clear_handover() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.handover_ != nullptr) _impl_.handover_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::DynStacking::HotStorage::DataModel::Handover& World::_internal_handover() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::Handover* p = _impl_.handover_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::Handover&>(::DynStacking::HotStorage::DataModel::_Handover_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::Handover& World::handover() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.Handover)
  return _internal_handover();
}
inline void World::unsafe_arena_set_allocated_handover(::DynStacking::HotStorage::DataModel::Handover* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.handover_);
  }
  _impl_.handover_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Handover*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.World.Handover)
}
inline ::DynStacking::HotStorage::DataModel::Handover* World::release_handover() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DynStacking::HotStorage::DataModel::Handover* released = _impl_.handover_;
  _impl_.handover_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::Handover* World::unsafe_arena_release_handover() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.World.Handover)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DynStacking::HotStorage::DataModel::Handover* temp = _impl_.handover_;
  _impl_.handover_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::Handover* World::_internal_mutable_handover() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.handover_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::Handover>(GetArena());
    _impl_.handover_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Handover*>(p);
  }
  return _impl_.handover_;
}
inline ::DynStacking::HotStorage::DataModel::Handover* World::mutable_handover() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::DynStacking::HotStorage::DataModel::Handover* _msg = _internal_mutable_handover();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.Handover)
  return _msg;
}
inline void World::set_allocated_handover(::DynStacking::HotStorage::DataModel::Handover* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.handover_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.handover_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Handover*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.World.Handover)
}

// .DynStacking.HotStorage.DataModel.Crane Crane = 5;
inline bool World::has_crane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.crane_ != nullptr);
  return value;
}
inline void World::clear_crane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.crane_ != nullptr) _impl_.crane_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::DynStacking::HotStorage::DataModel::Crane& World::_internal_crane() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::Crane* p = _impl_.crane_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::Crane&>(::DynStacking::HotStorage::DataModel::_Crane_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::Crane& World::crane() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.Crane)
  return _internal_crane();
}
inline void World::unsafe_arena_set_allocated_crane(::DynStacking::HotStorage::DataModel::Crane* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.crane_);
  }
  _impl_.crane_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Crane*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.World.Crane)
}
inline ::DynStacking::HotStorage::DataModel::Crane* World::release_crane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::DynStacking::HotStorage::DataModel::Crane* released = _impl_.crane_;
  _impl_.crane_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::Crane* World::unsafe_arena_release_crane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.World.Crane)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::DynStacking::HotStorage::DataModel::Crane* temp = _impl_.crane_;
  _impl_.crane_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::Crane* World::_internal_mutable_crane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.crane_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::Crane>(GetArena());
    _impl_.crane_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Crane*>(p);
  }
  return _impl_.crane_;
}
inline ::DynStacking::HotStorage::DataModel::Crane* World::mutable_crane() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::DynStacking::HotStorage::DataModel::Crane* _msg = _internal_mutable_crane();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.Crane)
  return _msg;
}
inline void World::set_allocated_crane(::DynStacking::HotStorage::DataModel::Crane* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.crane_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.crane_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Crane*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.World.Crane)
}

// .DynStacking.HotStorage.DataModel.Performance KPIs = 6;
inline bool World::has_kpis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kpis_ != nullptr);
  return value;
}
inline void World::clear_kpis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kpis_ != nullptr) _impl_.kpis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::DynStacking::HotStorage::DataModel::Performance& World::_internal_kpis() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::Performance* p = _impl_.kpis_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::Performance&>(::DynStacking::HotStorage::DataModel::_Performance_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::Performance& World::kpis() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.KPIs)
  return _internal_kpis();
}
inline void World::unsafe_arena_set_allocated_kpis(::DynStacking::HotStorage::DataModel::Performance* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kpis_);
  }
  _impl_.kpis_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Performance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.World.KPIs)
}
inline ::DynStacking::HotStorage::DataModel::Performance* World::release_kpis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DynStacking::HotStorage::DataModel::Performance* released = _impl_.kpis_;
  _impl_.kpis_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::Performance* World::unsafe_arena_release_kpis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.World.KPIs)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DynStacking::HotStorage::DataModel::Performance* temp = _impl_.kpis_;
  _impl_.kpis_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::Performance* World::_internal_mutable_kpis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kpis_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::Performance>(GetArena());
    _impl_.kpis_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Performance*>(p);
  }
  return _impl_.kpis_;
}
inline ::DynStacking::HotStorage::DataModel::Performance* World::mutable_kpis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::DynStacking::HotStorage::DataModel::Performance* _msg = _internal_mutable_kpis();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.KPIs)
  return _msg;
}
inline void World::set_allocated_kpis(::DynStacking::HotStorage::DataModel::Performance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.kpis_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.kpis_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Performance*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.World.KPIs)
}

// .DynStacking.HotStorage.DataModel.Uncertainties ObservationData = 7;
inline bool World::has_observationdata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.observationdata_ != nullptr);
  return value;
}
inline void World::clear_observationdata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.observationdata_ != nullptr) _impl_.observationdata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::DynStacking::HotStorage::DataModel::Uncertainties& World::_internal_observationdata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DynStacking::HotStorage::DataModel::Uncertainties* p = _impl_.observationdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::DynStacking::HotStorage::DataModel::Uncertainties&>(::DynStacking::HotStorage::DataModel::_Uncertainties_default_instance_);
}
inline const ::DynStacking::HotStorage::DataModel::Uncertainties& World::observationdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.ObservationData)
  return _internal_observationdata();
}
inline void World::unsafe_arena_set_allocated_observationdata(::DynStacking::HotStorage::DataModel::Uncertainties* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.observationdata_);
  }
  _impl_.observationdata_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Uncertainties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DynStacking.HotStorage.DataModel.World.ObservationData)
}
inline ::DynStacking::HotStorage::DataModel::Uncertainties* World::release_observationdata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::DynStacking::HotStorage::DataModel::Uncertainties* released = _impl_.observationdata_;
  _impl_.observationdata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DynStacking::HotStorage::DataModel::Uncertainties* World::unsafe_arena_release_observationdata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DynStacking.HotStorage.DataModel.World.ObservationData)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::DynStacking::HotStorage::DataModel::Uncertainties* temp = _impl_.observationdata_;
  _impl_.observationdata_ = nullptr;
  return temp;
}
inline ::DynStacking::HotStorage::DataModel::Uncertainties* World::_internal_mutable_observationdata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.observationdata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DynStacking::HotStorage::DataModel::Uncertainties>(GetArena());
    _impl_.observationdata_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Uncertainties*>(p);
  }
  return _impl_.observationdata_;
}
inline ::DynStacking::HotStorage::DataModel::Uncertainties* World::mutable_observationdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::DynStacking::HotStorage::DataModel::Uncertainties* _msg = _internal_mutable_observationdata();
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.ObservationData)
  return _msg;
}
inline void World::set_allocated_observationdata(::DynStacking::HotStorage::DataModel::Uncertainties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.observationdata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.observationdata_ = reinterpret_cast<::DynStacking::HotStorage::DataModel::Uncertainties*>(value);
  // @@protoc_insertion_point(field_set_allocated:DynStacking.HotStorage.DataModel.World.ObservationData)
}

// repeated .DynStacking.HotStorage.DataModel.CraneMove InvalidMoves = 8;
inline int World::_internal_invalidmoves_size() const {
  return _internal_invalidmoves().size();
}
inline int World::invalidmoves_size() const {
  return _internal_invalidmoves_size();
}
inline void World::clear_invalidmoves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalidmoves_.Clear();
}
inline ::DynStacking::HotStorage::DataModel::CraneMove* World::mutable_invalidmoves(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DynStacking.HotStorage.DataModel.World.InvalidMoves)
  return _internal_mutable_invalidmoves()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>* World::mutable_invalidmoves()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DynStacking.HotStorage.DataModel.World.InvalidMoves)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_invalidmoves();
}
inline const ::DynStacking::HotStorage::DataModel::CraneMove& World::invalidmoves(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DynStacking.HotStorage.DataModel.World.InvalidMoves)
  return _internal_invalidmoves().Get(index);
}
inline ::DynStacking::HotStorage::DataModel::CraneMove* World::add_invalidmoves() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DynStacking::HotStorage::DataModel::CraneMove* _add = _internal_mutable_invalidmoves()->Add();
  // @@protoc_insertion_point(field_add:DynStacking.HotStorage.DataModel.World.InvalidMoves)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>& World::invalidmoves() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DynStacking.HotStorage.DataModel.World.InvalidMoves)
  return _internal_invalidmoves();
}
inline const ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>&
World::_internal_invalidmoves() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invalidmoves_;
}
inline ::google::protobuf::RepeatedPtrField<::DynStacking::HotStorage::DataModel::CraneMove>*
World::_internal_mutable_invalidmoves() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.invalidmoves_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace DataModel
}  // namespace HotStorage
}  // namespace DynStacking


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // hotstorage_5fmodel_2eproto_2epb_2eh
